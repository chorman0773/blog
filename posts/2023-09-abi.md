# ABI Compatability - Promises, Lies, and Case Studies

[![Creative Commons License](https://i.creativecommons.org/l/by/4.0/80x15.png)](http://creativecommons.org/licenses/by/4.0/)

All content on this blog is licensed under the CC-BY 4.0 License. 

## What is ABI

ABI, or Application Binary Interface, is, simply put, the interface between two pieces of compiled code (or handwritten assembly). It describes how to coordinate between procedures/functions defined in two different translation units, and limited ability to specially arrange an interface. This can be thought to mirror how the API, Application Programming Interface, coordinates how you call functions at the source code level, by describing what parameters are expected at what types, and what type (if any) the function will return to the caller. 

ABI can be separated into 4 main parts:
1. The layout of certain types, particularily when those types may be accessed by pointer,
2. The number of parameters and return values, and where the caller places and expects them to be placed,
3. Responsibility for cleaning up resources used specifically for the function call, including registers used by the function, and
4. The mechanism for dispatching the function call and returning from the function call.

There are additional parts (such as how functions are supposed to return "abnormally") but the above are the main parts of ABI. You can recombine the last 3 points into a single "Calling Convention", however they are addressed here separately. Layout is usually assigned program-wide, whereas calling convention typically differs per-function, both as signatures and explicit ABI specification change.

## How is ABI Assigned

ABI is assigned in a number of places, including:
1. The specific platform, particularily processor achitecture and operating system,
2. The language the function is defined in, and
3. The specific implementation of the language.

(3) can be further subdivided into ABIs which are agreed upon by several implementations, and usually is defined by an outside body (for example, the Itanium C++ ABI), and implementation-local ABIs.

Typically, designs for (2) and (3) will be heavily based on, or inherit from, more specific designs for (1), sometimes by providing "Lowerings" of language- or implementation-specific signatures and ABIs to a platform-specific signature and ABI. This is not always the case, however. For example, the Microsoft "fastcall" convention originated as a toolchain specific ABI that was defined directly in terms of specific targets.


Choice of language can influence where ABI for code is likely assigned. For example:
* Code written in the C language most likely will have it's ABI determined by the target exclusively,
* Code written in the Swift language most likely will have it's ABI determined by the language,
* Code written in the C++ language most likely will have it's ABI determined by an agreed upon ABI Specification,
* Code written in the Rust language most likely will have it's ABI determined by the specific implementation of Rust.

## Layouts 

### What is in a layout

The "layout" of a type can be separated into a series of properties:
1. The size that a type occupies in memory,
2. The alignment that the type demands,
3. Which bits participate in determining the value of the type (value bits), and which do not participate (padding bits),
4. What values are not allowed (invalid values or trap representations),
5. How valid (and invalid) values are represented in the value bits,
6. How the type participates in Calling Convention determination.


